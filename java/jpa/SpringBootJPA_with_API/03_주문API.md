컬렉션 조회 최적화



entity -> dto로 변경시, entity안에 또 다른 entity가 필드로 존재할 시 (ex. List<OrderItem>) 해당 entity도 영속성 컨텍스트에 등록해 줘야 한다.

 이유로,

1. dto 생성 시, 접근하지 못했던 entity를 조회해여 영속성 컨텍스트에 등록시켜 주거나,(lazy loading때문에) 하는 작업이 필요함.

하지만 위의 케이스도 역시 문제점은 entity를 직접조회 한다는 것. 직접 조회 하게되면 entity의 스펙이 달라질 때 함께 영향을 받게된다.



entity -> dto로 변경 시,

entity가 직접 노출이 되면, 변경에 취약 & 원하는 스펙으로 전달학 ㅣ어렵기 때문에 dto로 변경함

이 때, entity안에 entity 컬렉션이 있다면, 컬렉션도 dto로 변경 해 줘야함.

컬렉션 조회 시 , 영속성 컨텍스트에 등록하는 작업을 해야하고, 해당 컬렉션의 size 만큼 쿼리가 실행되는 문제가 있음

 -> 이 문제를 해결하기 위해 fetch join 사용해보기



fetch join

쿼리 실행시 관련된 entity들을 join fetch 를 사용해서 함께 가져옴.

문제는  1:n의 문제로 인해 조회하는 쿼리가, 데이터베이스 조인에 의해 출력 쿼리가 2배로 는다.

![스크린샷 2020-06-20 오후 4.19.36](/Users/gwangyukim/Library/Application Support/typora-user-images/스크린샷 2020-06-20 오후 4.19.36.png)

**데이터 중복 발생**

![스크린샷 2020-06-20 오후 4.25.59](/Users/gwangyukim/Library/Application Support/typora-user-images/스크린샷 2020-06-20 오후 4.25.59.png)





해결하기 위해서, distinct를 넣어주면 된다. (v3)

- db의 distinct 키워드를 날려주고,
- **root entity가 중복인 경우, 중복을 날려서 데이터를 줄여줌**
  - 성능 최적화에 엄청 좋음
- 단점 : **페이징 불가능**
  - 컬렉션 페치조인을 사용하면 페이징이 불가능함.
  - 하이버네이트에서 경고로그를 남기며, 모든 데이터를 db 에서 읽어오고, 메모리에서 페이징함.
- 단점2: 컬렉션 페치조인은 1개만 사용할 수 있음
  - 둘 이상에서 페치조인을 하면, 데이터가 부정합하게 조회가 될 수 있음.

