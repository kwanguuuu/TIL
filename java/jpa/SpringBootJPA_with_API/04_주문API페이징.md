##페이징과 한계 돌파

1. 컬렉션을 페치조인 하면 페이징이 불가능 하다
   - 컬렉션을 페치 조인하면 일대다 조인이 발생하므로 데이터가 예측할 수 없이 증가함.
   - 일대다에서 **일(1)**을 기준으로 페이징이 목적. 하지만 데이터는 **다(N)**를 기준으로 row가 생성됨
   - ex. Order를 기준으로 데이터를 생성하고 싶은데, 결과 데이터는 OrderItem을 기준으로 생성이됨.
2. 하이버네이트는 경고로그를 남기고 모든 DB 데이터를 읽어서 메모리에서 페이징을 시도함. (최악은 장애로 연결됨)



***페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야함?***

1. XToOne 관계를 모두 페치조인함. ToOne 관계는 Row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않음
2. 컬렉션은 지연 로딩으로 조회한다.
3. 지연로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size`, `@BatchSize`를 적용한다.
   - `hibernate.default_batch_fetch_size`: 글로벌 설정
   - `@BatchSize`: 개별 최적화

**장점**

- 쿼리 호출 수가 `1+N` -> `1+1`로 최적화 된다.
- 조인보다 db 데이터 전송량이 최적화된다.
  (Order와 OrderItem을 조인하면 Order가 OrderItem 만큼 중복해서 조회된다. 이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없다.)
- 페치 조인 방식과 비교해서 쿼리 호출수가 약간 증가하지만, DB 데이터 전송량이 감소한다.
- 컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 페이징이 가능하다.

**결론**

- ToOne관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne관계는 페치조인으로 쿼리 수를 줄이고, 나머지는 `hibernate.default_batch_fetch_size`로 최적화하자.

---



JPA에서 DTO 직접 조회 (v4)

- Query: 루트1번, 컬렉션  N번 실행 (N+1 문제 발생)
- ToOne 관계를 먼저 조회 하고, ToMany 관계는 각각 별도 처리
  - ToOne관계는 조인해도 row 가 증가하지 않는데
  - ToMany 관계는 조인하면 row수가 증가함
- row수가 증가하지 않는 ToOne관계는 조인으로 최적화 하기 쉬우므로 한번에 조회하고, ToMany관계는 최적화 하기 어려우니 findOrderItems()와 같은 별도 메서드로 조회한다

