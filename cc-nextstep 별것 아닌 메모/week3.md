## 3주차 20200401

### 로또 피드백

- TDD 사이클이 익숙해 질 때 까지, **같은 미션을 반복** 하는거 중요함.

- 알고 있는거 연습할 때, 재밌. ㅇㅇ ( 컴포트 존 )

  - 자존감 떨어지면, 했던 프로그램을 다시 연습해 보는것 좋은 방법 중 하나.

- 어디서 어떻게 해야할지 모를떄, 요구사항 분석을 철저히 해라.

- TDD를 한다고 요구사항 분석, 설계를 더 안해도 되는건 아니다.

- 구현 중간부분을 자르는 연습을 해라

  - TDD를 잘 할 수 있는 방법중 하나.

  - ex, 구매한 로또와 당첨 번호를 넣으면 당첨 결과를 반환한다.
  - 당첨 결과를 입력하면 당첨금 총액을 반환한다.

- 구현 중간 부분을 자른다는 것은 구현에 필요한 메소드를 찾는 과정이라고 생각한다.



### 시작하기

- 객체설계가 어렵다면, 클래스메서드 구현으로 시작하면서 만들어 보자. -> 나중에 리팩토링하면 되니까

- 1순위 : 메서드 분리, 좋은 이름을 rename하는 리팩토링

  

  

  bottom - up 방식 중요



클래스 간의 의존관계 연결

- 클래스를 분리할 때 클래스 간의 의존관계를 어떻게 할 것인가.
- is -a 관계 (상속), has -a 관계(조합)
  - 일급 컬렉션을 구현할 때, 접근방법으로 상속&조합 사용할 수 있음.
  - 객체의 중복을 제거할 때 역시 사용할 수 있음.
- 상속으로 구현한다면..? -> 상속받은 부모가 제공하는 모든 API를 다 제공하게 됨.
- 상속은 재사용성 측면에서는 유리, 유연성 측면에서는 조합(has -a)관계가 더 유리함.
  - 상속 관계일떄, 부모 클래스의 어떤 값or 메소드 변경이 자식 클래스 모두에 영향을 미친다.
  - 상속으로 되어있는건 변화가 생겼을 때 짜증나기 쉽다.
  - 재사용성 보다는 유연성이 더 중요함.

추가 리팩토링

- 생성자 대신 정적 팩토리 메서드를 사용하라.
  - 이름을 가져서, 생성의 의도를 드러 낼 수 있음
  - 호출 때 마다 인스턴스를 새로 안만들어도 됨 ( 이펙티브 자바 참조 )
  - 다양항 방식의 생성자를 만들면, API를 사용하는 사용자를 배려하는 방법일 수도 있다.
- mutable object보다 immutable object를 사용해 봐라.

가변객체 vs 불변객체

- 가변객체 : 초기화 한 이후에 값이 변할 수 있는 객체

- 불변객체 : 초기화 한 이후에 값이 변하지 않는 객체
  - 객체의 상태를 변경하는 메소드 제공 x
  - 클래스 확장할 수 없도록 한다.
  - 모든 필드를 final로
    - 단, final이 선언되었다고 불변객체를 보장하는 건 아님 (ex. 컬렉션 내부)
  - 모든 필드를 private으로 선언.

immutableObject의 질문

- 좋은데, 인스턴스가 너무 많이 성능이 떨어질 수 있지 않은가?
- 캐싱을 적용해 인스턴스 생성을최소화 할 수 있는 방법이 있는지 검토한다.
  - 캐싱을 쓸 때 가장 많이 사용하는 자료구조는 map, 방식의 자료구조.
  - 정적 팩토리 메서드 방식.
  - 캐싱을 TDD의 사이클로 적용, 테스트 할 때, ==으로 비교해보자 (ex. of("8" == of(8)) )



---



Step3 관련.

사다리 타기 하면서 해봤으면 하는것?

- 인터페이스 추출을 해봤으면 좋겠다.
- 스트림, 람다를 사용해 함수형 프로그래밍하는 경험을 한다.



함수형 프로그램을 해야하는 이유.?

- 상태를 공유하는 프로그램이 있을 떄, 동시성 이슈를 해결하는데 효과적. ( 왜 mutable 객체를 사용하지 않아야 하는지. )
- 대용량 데이터를 처리하는 데 효율적인 데이터 구조와 연사를 필요함. (객체 프로그램은 인스턴스를 계속 만들어야 함.)
- 클래스 ( 데이터와 행위의 묶음), 함수는 모듈 단위가 함수기 떄문에, 더 작은 단위 모듈이 가능함.
  - 재사용 편리, 구성용이,테스트하기 용이
  - 

